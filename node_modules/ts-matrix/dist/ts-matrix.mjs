var z = Object.defineProperty;
var f = (m, t, s) => t in m ? z(m, t, { enumerable: !0, configurable: !0, writable: !0, value: s }) : m[t] = s;
var v = (m, t, s) => (f(m, typeof t != "symbol" ? t + "" : t, s), s);
class c {
  constructor(t, s, e) {
    v(this, "_rows");
    v(this, "_columns");
    v(this, "_values");
    this._rows = Math.max(t, 1), this._columns = Math.max(s, 1), this._values = new Array(this._rows).fill([]).map(() => new Array(this._columns).fill(0)), e && (this.values = e);
  }
  get rows() {
    return this._rows;
  }
  get columns() {
    return this._columns;
  }
  get values() {
    return this._values;
  }
  set values(t) {
    const s = Math.min(t.length, this.rows), e = Math.min(t[0].length, this.columns);
    for (let r = 0; r < s; r++)
      for (let i = 0; i < e; i++)
        this.values[r][i] = t[r][i];
  }
  at(t, s) {
    return this.values[t][s];
  }
  reset() {
    this.values = this.values.map((t) => t.map(() => 0));
  }
  addAColumn() {
    return new c(this.rows, this.columns + 1, this.values);
  }
  addARow() {
    return new c(this.rows + 1, this.columns, this.values);
  }
  equals(t) {
    return this.rows === t.rows && this.columns === t.columns && this.values.reduce(
      (s, e, r) => s && e.reduce(
        (i, n, h) => i && t.at(r, h) === n,
        s
      ),
      !0
    );
  }
  setAsIdentity() {
    if (this.rows !== this.columns)
      throw new Error("Dimension error! The matrix isn't squared!");
    return this.values.forEach((t, s) => {
      t.forEach((e, r) => {
        this.values[s][r] = s === r ? 1 : 0;
      });
    }), this;
  }
  static identity(t) {
    if (t < 1)
      throw Error("Dimension error! Matrix dimension must be positive.");
    return new c(t, t).setAsIdentity();
  }
  multiply(t) {
    if (this.columns !== t.rows)
      throw new Error("Dimension error! The operand matrix must have the same number of rows as 'this' matrix columns!");
    const s = new c(this.rows, t.columns);
    return s.values = s.values.map((e, r) => e.map((i, n) => this.values[r].reduce((h, a, o) => h + a * t.at(o, n), 0))), s;
  }
  determinant() {
    if (this.rows !== this.columns)
      throw new Error("Dimension error! The matrix isn't squared!");
    if (this.rows === this.columns && this.columns === 1)
      return this.values[0][0];
    let t = 0, s = 1;
    if (this.rows === 2)
      t = this.values[0][0] * this.values[1][1] - this.values[1][0] * this.values[0][1];
    else
      for (let e = 0; e < this.rows; e++) {
        const r = this.getCofactor(0, e);
        t += s * this.at(0, e) * r.determinant(), s = -s;
      }
    return t;
  }
  getCofactor(t, s) {
    return new c(this.rows - 1, this.columns - 1, this.values.filter((e, r) => r !== t).map((e) => e.filter((r, i) => i !== s)));
  }
  transpose() {
    return new c(this.columns, this.rows, new Array(this.columns).fill([]).map((t, s) => new Array(this.rows).fill(0).map((e, r) => this.at(r, s))));
  }
  inverse() {
    if (this.rows !== this.columns)
      throw new Error("Dimension error! The matrix isn't squared!");
    const t = this.determinant();
    if (t === 0)
      throw new Error("Determinant is 0, can't compute inverse.");
    const e = new c(
      this.rows,
      this.columns,
      this.values.map((r, i) => r.map((n, h) => Math.pow(-1, i + h) * this.getCofactor(i, h).determinant()))
    ).transpose();
    return new c(
      this.rows,
      this.columns,
      this.values.map((r, i) => r.map((n, h) => e.at(i, h) / t))
    );
  }
}
class y {
  constructor(t) {
    v(this, "_values");
    this._values = new Array((t || [0]).length).fill(0), t && (this.values = t);
  }
  get rows() {
    return this.values.length;
  }
  get values() {
    return this._values;
  }
  set values(t) {
    const s = Math.min(this.values.length, t.length);
    for (let e = 0; e < s; e++)
      this.values[e] = t[e];
  }
  at(t) {
    return this.values[t];
  }
  reset() {
    this.values = this.values.fill(0);
  }
  addAValue() {
    return this.values.push(0), new y(this.values);
  }
  equals(t) {
    return this.rows === t.rows && this.values.reduce((s, e, r) => s && t.at(r) === e, !0);
  }
  negate() {
    return new y(this.values.map((t) => -t));
  }
  length() {
    return Math.sqrt(this.squaredLength());
  }
  squaredLength() {
    return this.dot(this);
  }
  add(t) {
    if (this.rows !== t.rows)
      throw new Error("Vectors don't have the same dimension!");
    return this.operateOnAllValues((s, e) => s + t.at(e));
  }
  substract(t) {
    if (this.rows !== t.rows)
      throw new Error("Vectors don't have the same dimension!");
    return this.operateOnAllValues((s, e) => s - t.at(e));
  }
  multiply(t) {
    if (this.rows !== t.rows)
      throw new Error("Vectors don't have the same dimension!");
    return this.operateOnAllValues((s, e) => s * t.at(e));
  }
  divide(t) {
    if (this.rows !== t.rows)
      throw new Error("Vectors don't have the same dimension!");
    return this.operateOnAllValues((s, e) => t.at(e) === 0 ? s : s / t.at(e));
  }
  scale(t) {
    return this.operateOnAllValues((s) => s * t);
  }
  operateOnAllValues(t) {
    return new y(this.values.map(t));
  }
  normalize() {
    const t = this.length();
    return this.operateOnAllValues((s) => s / t);
  }
  dot(t) {
    return this.values.reduce((s, e, r) => s + e * t.at(r), 0);
  }
  cross(t) {
    if (this.rows < 3 || t.rows < 3)
      throw new Error("Cross product is possible on 3D vectors only");
    const s = new Array(3);
    return s[0] = this.at(1) * t.at(2) - this.at(2) * t.at(1), s[1] = this.at(2) * t.at(0) - this.at(0) * t.at(2), s[2] = this.at(0) * t.at(1) - this.at(1) * t.at(0), new y(s);
  }
  mix(t, s) {
    return new y(this.values.map((e, r) => e + s * (t.at(r) - e)));
  }
  static get360angle(t, s) {
    if (t.rows !== 3 || s.rows !== 3)
      throw new Error("Vectors must be in 3D!. You can add a 1 dimension if it is missing.");
    return -Math.atan2(
      s.cross(t).dot(new y([0, 0, 1]).normalize()),
      t.dot(s)
    );
  }
}
const d = 1e-5, w = class {
  constructor(t) {
    v(this, "values", new Float32Array(4));
    t !== void 0 && (this.xyzw = t);
  }
  get x() {
    return this.values[0];
  }
  set x(t) {
    this.values[0] = t;
  }
  get y() {
    return this.values[1];
  }
  set y(t) {
    this.values[1] = t;
  }
  get z() {
    return this.values[2];
  }
  set z(t) {
    this.values[2] = t;
  }
  get w() {
    return this.values[3];
  }
  set w(t) {
    this.values[3] = t;
  }
  get xy() {
    return [
      this.values[0],
      this.values[1]
    ];
  }
  set xy(t) {
    this.values[0] = t[0], this.values[1] = t[1];
  }
  get xyz() {
    return [
      this.values[0],
      this.values[1],
      this.values[2]
    ];
  }
  set xyz(t) {
    this.values[0] = t[0], this.values[1] = t[1], this.values[2] = t[2];
  }
  get xyzw() {
    return [
      this.values[0],
      this.values[1],
      this.values[2],
      this.values[3]
    ];
  }
  set xyzw(t) {
    this.values[0] = t[0], this.values[1] = t[1], this.values[2] = t[2], this.values[3] = t[3];
  }
  at(t) {
    return this.values[t];
  }
  reset() {
    for (let t = 0; t < 4; t++)
      this.values[t] = 0;
  }
  copy(t) {
    t || (t = new w());
    for (let s = 0; s < 4; s++)
      t.values[s] = this.values[s];
    return t;
  }
  roll() {
    const t = this.x, s = this.y, e = this.z, r = this.w;
    return Math.atan2(2 * (t * s + r * e), r * r + t * t - s * s - e * e);
  }
  pitch() {
    const t = this.x, s = this.y, e = this.z, r = this.w;
    return Math.atan2(2 * (s * e + r * t), r * r - t * t - s * s + e * e);
  }
  yaw() {
    return Math.asin(2 * (this.x * this.z - this.w * this.y));
  }
  equals(t, s = d) {
    for (let e = 0; e < 4; e++)
      if (Math.abs(this.values[e] - t.at(e)) > s)
        return !1;
    return !0;
  }
  setIdentity() {
    return this.x = 0, this.y = 0, this.z = 0, this.w = 1, this;
  }
  calculateW() {
    const t = this.x, s = this.y, e = this.z;
    return this.w = -Math.sqrt(Math.abs(1 - t * t - s * s - e * e)), this;
  }
  inverse() {
    const t = w.dot(this, this);
    if (!t)
      return this.xyzw = [0, 0, 0, 0], this;
    const s = t ? 1 / t : 0;
    return this.x *= -s, this.y *= -s, this.z *= -s, this.w *= s, this;
  }
  conjugate() {
    return this.values[0] *= -1, this.values[1] *= -1, this.values[2] *= -1, this;
  }
  length() {
    const t = this.x, s = this.y, e = this.z, r = this.w;
    return Math.sqrt(t * t + s * s + e * e + r * r);
  }
  normalize(t) {
    t || (t = this);
    const s = this.x, e = this.y, r = this.z, i = this.w;
    let n = Math.sqrt(s * s + e * e + r * r + i * i);
    return n ? (n = 1 / n, t.x = s * n, t.y = e * n, t.z = r * n, t.w = i * n, t) : (t.x = 0, t.y = 0, t.z = 0, t.w = 0, t);
  }
  add(t) {
    for (let s = 0; s < 4; s++)
      this.values[s] += t.at(s);
    return this;
  }
  multiply(t) {
    const s = this.values[0], e = this.values[1], r = this.values[2], i = this.values[3], n = t.x, h = t.y, a = t.z, o = t.w;
    return this.x = s * o + i * n + e * a - r * h, this.y = e * o + i * h + r * n - s * a, this.z = r * o + i * a + s * h - e * n, this.w = i * o - s * n - e * h - r * a, this;
  }
  static dot(t, s) {
    return t.x * s.x + t.y * s.y + t.z * s.z + t.w * s.w;
  }
  static sum(t, s) {
    const e = new w();
    return e.x = t.x + s.x, e.y = t.y + s.y, e.z = t.z + s.z, e.w = t.w + s.w, e;
  }
  static product(t, s) {
    const e = new w(), r = t.x, i = t.y, n = t.z, h = t.w, a = s.x, o = s.y, u = s.z, l = s.w;
    return e.x = r * l + h * a + i * u - n * o, e.y = i * l + h * o + n * a - r * u, e.z = n * l + h * u + r * o - i * a, e.w = h * l - r * a - i * o - n * u, e;
  }
  static cross(t, s) {
    const e = new w(), r = t.x, i = t.y, n = t.z, h = t.w, a = s.x, o = s.y, u = s.z, l = s.w;
    return e.x = h * u + n * l + r * o - i * a, e.y = h * l - r * a - i * o - n * u, e.z = h * a + r * l + i * u - n * o, e.w = h * o + i * l + n * a - r * u, e;
  }
  static shortMix(t, s, e) {
    const r = new w();
    if (e <= 0)
      return r.xyzw = t.xyzw, r;
    if (e >= 1)
      return r.xyzw = s.xyzw, r;
    let i = w.dot(t, s);
    const n = s.copy();
    i < 0 && (n.inverse(), i = -i);
    let h, a;
    if (i > 0.9999)
      h = 1 - e, a = 0 + e;
    else {
      const o = Math.sqrt(1 - i * i), u = Math.atan2(o, i), l = 1 / o;
      h = Math.sin((1 - e) * u) * l, a = Math.sin((0 + e) * u) * l;
    }
    return r.x = h * t.x + a * n.x, r.y = h * t.y + a * n.y, r.z = h * t.z + a * n.z, r.w = h * t.w + a * n.w, r;
  }
  static mix(t, s, e) {
    const r = new w(), i = t.x * s.x + t.y * s.y + t.z * s.z + t.w * s.w;
    if (Math.abs(i) >= 1)
      return r.xyzw = t.xyzw, r;
    const n = Math.acos(i), h = Math.sqrt(1 - i * i);
    if (Math.abs(h) < 1e-3)
      return r.x = t.x * 0.5 + s.x * 0.5, r.y = t.y * 0.5 + s.y * 0.5, r.z = t.z * 0.5 + s.z * 0.5, r.w = t.w * 0.5 + s.w * 0.5, r;
    const a = Math.sin((1 - e) * n) / h, o = Math.sin(e * n) / h;
    return r.x = t.x * a + s.x * o, r.y = t.y * a + s.y * o, r.z = t.z * a + s.z * o, r.w = t.w * a + s.w * o, r;
  }
  static fromAxisAngle(t, s) {
    if (t.rows !== 3)
      throw new Error("The axis vector must be in 3D!");
    const e = new w();
    s *= 0.5;
    const r = Math.sin(s);
    return e.x = t.at(0) * r, e.y = t.at(1) * r, e.z = t.at(2) * r, e.w = Math.cos(s), e;
  }
};
let x = w;
v(x, "identity", new w().setIdentity());
export {
  c as Matrix,
  x as Quat,
  y as Vector
};
//# sourceMappingURL=ts-matrix.mjs.map
