(function(l,u){typeof exports=="object"&&typeof module<"u"?u(exports):typeof define=="function"&&define.amd?define(["exports"],u):(l=typeof globalThis<"u"?globalThis:l||self,u(l["ts-matrix"]={}))})(this,function(l){"use strict";var z=Object.defineProperty;var d=(l,u,w)=>u in l?z(l,u,{enumerable:!0,configurable:!0,writable:!0,value:w}):l[u]=w;var m=(l,u,w)=>(d(l,typeof u!="symbol"?u+"":u,w),w);class u{constructor(t,s,e){m(this,"_rows");m(this,"_columns");m(this,"_values");this._rows=Math.max(t,1),this._columns=Math.max(s,1),this._values=new Array(this._rows).fill([]).map(()=>new Array(this._columns).fill(0)),e&&(this.values=e)}get rows(){return this._rows}get columns(){return this._columns}get values(){return this._values}set values(t){const s=Math.min(t.length,this.rows),e=Math.min(t[0].length,this.columns);for(let r=0;r<s;r++)for(let i=0;i<e;i++)this.values[r][i]=t[r][i]}at(t,s){return this.values[t][s]}reset(){this.values=this.values.map(t=>t.map(()=>0))}addAColumn(){return new u(this.rows,this.columns+1,this.values)}addARow(){return new u(this.rows+1,this.columns,this.values)}equals(t){return this.rows===t.rows&&this.columns===t.columns&&this.values.reduce((s,e,r)=>s&&e.reduce((i,n,o)=>i&&t.at(r,o)===n,s),!0)}setAsIdentity(){if(this.rows!==this.columns)throw new Error("Dimension error! The matrix isn't squared!");return this.values.forEach((t,s)=>{t.forEach((e,r)=>{this.values[s][r]=s===r?1:0})}),this}static identity(t){if(t<1)throw Error("Dimension error! Matrix dimension must be positive.");return new u(t,t).setAsIdentity()}multiply(t){if(this.columns!==t.rows)throw new Error("Dimension error! The operand matrix must have the same number of rows as 'this' matrix columns!");const s=new u(this.rows,t.columns);return s.values=s.values.map((e,r)=>e.map((i,n)=>this.values[r].reduce((o,h,a)=>o+h*t.at(a,n),0))),s}determinant(){if(this.rows!==this.columns)throw new Error("Dimension error! The matrix isn't squared!");if(this.rows===this.columns&&this.columns===1)return this.values[0][0];let t=0,s=1;if(this.rows===2)t=this.values[0][0]*this.values[1][1]-this.values[1][0]*this.values[0][1];else for(let e=0;e<this.rows;e++){const r=this.getCofactor(0,e);t+=s*this.at(0,e)*r.determinant(),s=-s}return t}getCofactor(t,s){return new u(this.rows-1,this.columns-1,this.values.filter((e,r)=>r!==t).map(e=>e.filter((r,i)=>i!==s)))}transpose(){return new u(this.columns,this.rows,new Array(this.columns).fill([]).map((t,s)=>new Array(this.rows).fill(0).map((e,r)=>this.at(r,s))))}inverse(){if(this.rows!==this.columns)throw new Error("Dimension error! The matrix isn't squared!");const t=this.determinant();if(t===0)throw new Error("Determinant is 0, can't compute inverse.");const e=new u(this.rows,this.columns,this.values.map((r,i)=>r.map((n,o)=>Math.pow(-1,i+o)*this.getCofactor(i,o).determinant()))).transpose();return new u(this.rows,this.columns,this.values.map((r,i)=>r.map((n,o)=>e.at(i,o)/t)))}}class w{constructor(t){m(this,"_values");this._values=new Array((t||[0]).length).fill(0),t&&(this.values=t)}get rows(){return this.values.length}get values(){return this._values}set values(t){const s=Math.min(this.values.length,t.length);for(let e=0;e<s;e++)this.values[e]=t[e]}at(t){return this.values[t]}reset(){this.values=this.values.fill(0)}addAValue(){return this.values.push(0),new w(this.values)}equals(t){return this.rows===t.rows&&this.values.reduce((s,e,r)=>s&&t.at(r)===e,!0)}negate(){return new w(this.values.map(t=>-t))}length(){return Math.sqrt(this.squaredLength())}squaredLength(){return this.dot(this)}add(t){if(this.rows!==t.rows)throw new Error("Vectors don't have the same dimension!");return this.operateOnAllValues((s,e)=>s+t.at(e))}substract(t){if(this.rows!==t.rows)throw new Error("Vectors don't have the same dimension!");return this.operateOnAllValues((s,e)=>s-t.at(e))}multiply(t){if(this.rows!==t.rows)throw new Error("Vectors don't have the same dimension!");return this.operateOnAllValues((s,e)=>s*t.at(e))}divide(t){if(this.rows!==t.rows)throw new Error("Vectors don't have the same dimension!");return this.operateOnAllValues((s,e)=>t.at(e)===0?s:s/t.at(e))}scale(t){return this.operateOnAllValues(s=>s*t)}operateOnAllValues(t){return new w(this.values.map(t))}normalize(){const t=this.length();return this.operateOnAllValues(s=>s/t)}dot(t){return this.values.reduce((s,e,r)=>s+e*t.at(r),0)}cross(t){if(this.rows<3||t.rows<3)throw new Error("Cross product is possible on 3D vectors only");const s=new Array(3);return s[0]=this.at(1)*t.at(2)-this.at(2)*t.at(1),s[1]=this.at(2)*t.at(0)-this.at(0)*t.at(2),s[2]=this.at(0)*t.at(1)-this.at(1)*t.at(0),new w(s)}mix(t,s){return new w(this.values.map((e,r)=>e+s*(t.at(r)-e)))}static get360angle(t,s){if(t.rows!==3||s.rows!==3)throw new Error("Vectors must be in 3D!. You can add a 1 dimension if it is missing.");return-Math.atan2(s.cross(t).dot(new w([0,0,1]).normalize()),t.dot(s))}}const x=1e-5,c=class{constructor(t){m(this,"values",new Float32Array(4));t!==void 0&&(this.xyzw=t)}get x(){return this.values[0]}set x(t){this.values[0]=t}get y(){return this.values[1]}set y(t){this.values[1]=t}get z(){return this.values[2]}set z(t){this.values[2]=t}get w(){return this.values[3]}set w(t){this.values[3]=t}get xy(){return[this.values[0],this.values[1]]}set xy(t){this.values[0]=t[0],this.values[1]=t[1]}get xyz(){return[this.values[0],this.values[1],this.values[2]]}set xyz(t){this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2]}get xyzw(){return[this.values[0],this.values[1],this.values[2],this.values[3]]}set xyzw(t){this.values[0]=t[0],this.values[1]=t[1],this.values[2]=t[2],this.values[3]=t[3]}at(t){return this.values[t]}reset(){for(let t=0;t<4;t++)this.values[t]=0}copy(t){t||(t=new c);for(let s=0;s<4;s++)t.values[s]=this.values[s];return t}roll(){const t=this.x,s=this.y,e=this.z,r=this.w;return Math.atan2(2*(t*s+r*e),r*r+t*t-s*s-e*e)}pitch(){const t=this.x,s=this.y,e=this.z,r=this.w;return Math.atan2(2*(s*e+r*t),r*r-t*t-s*s+e*e)}yaw(){return Math.asin(2*(this.x*this.z-this.w*this.y))}equals(t,s=x){for(let e=0;e<4;e++)if(Math.abs(this.values[e]-t.at(e))>s)return!1;return!0}setIdentity(){return this.x=0,this.y=0,this.z=0,this.w=1,this}calculateW(){const t=this.x,s=this.y,e=this.z;return this.w=-Math.sqrt(Math.abs(1-t*t-s*s-e*e)),this}inverse(){const t=c.dot(this,this);if(!t)return this.xyzw=[0,0,0,0],this;const s=t?1/t:0;return this.x*=-s,this.y*=-s,this.z*=-s,this.w*=s,this}conjugate(){return this.values[0]*=-1,this.values[1]*=-1,this.values[2]*=-1,this}length(){const t=this.x,s=this.y,e=this.z,r=this.w;return Math.sqrt(t*t+s*s+e*e+r*r)}normalize(t){t||(t=this);const s=this.x,e=this.y,r=this.z,i=this.w;let n=Math.sqrt(s*s+e*e+r*r+i*i);return n?(n=1/n,t.x=s*n,t.y=e*n,t.z=r*n,t.w=i*n,t):(t.x=0,t.y=0,t.z=0,t.w=0,t)}add(t){for(let s=0;s<4;s++)this.values[s]+=t.at(s);return this}multiply(t){const s=this.values[0],e=this.values[1],r=this.values[2],i=this.values[3],n=t.x,o=t.y,h=t.z,a=t.w;return this.x=s*a+i*n+e*h-r*o,this.y=e*a+i*o+r*n-s*h,this.z=r*a+i*h+s*o-e*n,this.w=i*a-s*n-e*o-r*h,this}static dot(t,s){return t.x*s.x+t.y*s.y+t.z*s.z+t.w*s.w}static sum(t,s){const e=new c;return e.x=t.x+s.x,e.y=t.y+s.y,e.z=t.z+s.z,e.w=t.w+s.w,e}static product(t,s){const e=new c,r=t.x,i=t.y,n=t.z,o=t.w,h=s.x,a=s.y,v=s.z,y=s.w;return e.x=r*y+o*h+i*v-n*a,e.y=i*y+o*a+n*h-r*v,e.z=n*y+o*v+r*a-i*h,e.w=o*y-r*h-i*a-n*v,e}static cross(t,s){const e=new c,r=t.x,i=t.y,n=t.z,o=t.w,h=s.x,a=s.y,v=s.z,y=s.w;return e.x=o*v+n*y+r*a-i*h,e.y=o*y-r*h-i*a-n*v,e.z=o*h+r*y+i*v-n*a,e.w=o*a+i*y+n*h-r*v,e}static shortMix(t,s,e){const r=new c;if(e<=0)return r.xyzw=t.xyzw,r;if(e>=1)return r.xyzw=s.xyzw,r;let i=c.dot(t,s);const n=s.copy();i<0&&(n.inverse(),i=-i);let o,h;if(i>.9999)o=1-e,h=0+e;else{const a=Math.sqrt(1-i*i),v=Math.atan2(a,i),y=1/a;o=Math.sin((1-e)*v)*y,h=Math.sin((0+e)*v)*y}return r.x=o*t.x+h*n.x,r.y=o*t.y+h*n.y,r.z=o*t.z+h*n.z,r.w=o*t.w+h*n.w,r}static mix(t,s,e){const r=new c,i=t.x*s.x+t.y*s.y+t.z*s.z+t.w*s.w;if(Math.abs(i)>=1)return r.xyzw=t.xyzw,r;const n=Math.acos(i),o=Math.sqrt(1-i*i);if(Math.abs(o)<.001)return r.x=t.x*.5+s.x*.5,r.y=t.y*.5+s.y*.5,r.z=t.z*.5+s.z*.5,r.w=t.w*.5+s.w*.5,r;const h=Math.sin((1-e)*n)/o,a=Math.sin(e*n)/o;return r.x=t.x*h+s.x*a,r.y=t.y*h+s.y*a,r.z=t.z*h+s.z*a,r.w=t.w*h+s.w*a,r}static fromAxisAngle(t,s){if(t.rows!==3)throw new Error("The axis vector must be in 3D!");const e=new c;s*=.5;const r=Math.sin(s);return e.x=t.at(0)*r,e.y=t.at(1)*r,e.z=t.at(2)*r,e.w=Math.cos(s),e}};let f=c;m(f,"identity",new c().setIdentity()),l.Matrix=u,l.Quat=f,l.Vector=w,Object.defineProperties(l,{__esModule:{value:!0},[Symbol.toStringTag]:{value:"Module"}})});
//# sourceMappingURL=ts-matrix.umd.js.map
