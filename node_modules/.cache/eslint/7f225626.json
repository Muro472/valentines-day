[{"/Users/muromac/uni/miroslavaLabs/src/main.ts":"1","/Users/muromac/uni/miroslavaLabs/src/App.vue":"2","/Users/muromac/uni/miroslavaLabs/src/router/index.ts":"3","/Users/muromac/uni/miroslavaLabs/src/store/index.ts":"4","/Users/muromac/uni/miroslavaLabs/src/views/labThree.vue":"5","/Users/muromac/uni/miroslavaLabs/src/views/labTwo.vue":"6","/Users/muromac/uni/miroslavaLabs/src/views/labOne.vue":"7","/Users/muromac/uni/miroslavaLabs/src/views/labFour.vue":"8","/Users/muromac/uni/miroslavaLabs/src/functions/gaus.ts":"9","/Users/muromac/uni/miroslavaLabs/src/functions/jakobi.ts":"10","/Users/muromac/uni/miroslavaLabs/src/functions/zeidel.ts":"11","/Users/muromac/uni/miroslavaLabs/src/functions/determinant.ts":"12","/Users/muromac/uni/miroslavaLabs/src/functions/inverse.ts":"13"},{"size":176,"mtime":1671470477628,"results":"14","hashOfConfig":"15"},{"size":289,"mtime":1671470477627,"results":"16","hashOfConfig":"15"},{"size":713,"mtime":1671470477628,"results":"17","hashOfConfig":"15"},{"size":115,"mtime":1671470477628,"results":"18","hashOfConfig":"15"},{"size":7512,"mtime":1674007872750,"results":"19","hashOfConfig":"15"},{"size":2142,"mtime":1671470477629,"results":"20","hashOfConfig":"15"},{"size":2395,"mtime":1671470477629,"results":"21","hashOfConfig":"15"},{"size":2834,"mtime":1674416381386,"results":"22","hashOfConfig":"15"},{"size":1352,"mtime":1671470477627,"results":"23","hashOfConfig":"15"},{"size":989,"mtime":1671470477628,"results":"24","hashOfConfig":"15"},{"size":1365,"mtime":1674026689766,"results":"25","hashOfConfig":"15"},{"size":554,"mtime":1671470477627,"results":"26","hashOfConfig":"15"},{"size":200,"mtime":1671470477628,"results":"27","hashOfConfig":"15"},{"filePath":"28","messages":"29","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"ejswvj",{"filePath":"31","messages":"32","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"33"},{"filePath":"34","messages":"35","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"36","messages":"37","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"38","messages":"39","errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"40","usedDeprecatedRules":"33"},{"filePath":"41","messages":"42","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"33"},{"filePath":"43","messages":"44","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"33"},{"filePath":"45","messages":"46","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},{"filePath":"47","messages":"48","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"49","messages":"50","errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"51","usedDeprecatedRules":"30"},{"filePath":"52","messages":"53","errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"54","usedDeprecatedRules":"30"},{"filePath":"55","messages":"56","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},{"filePath":"57","messages":"58","errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":"30"},"/Users/muromac/uni/miroslavaLabs/src/main.ts",[],[],"/Users/muromac/uni/miroslavaLabs/src/App.vue",[],[],"/Users/muromac/uni/miroslavaLabs/src/router/index.ts",[],"/Users/muromac/uni/miroslavaLabs/src/store/index.ts",[],"/Users/muromac/uni/miroslavaLabs/src/views/labThree.vue",["59","60","61","62","63"],"<template>\n  <div class=\"wrap\">\n    <div class=\"table\">\n      <div v-for=\"(_, index) in arr\" :key=\"index\">\n        <input\n          class=\"cell\"\n          type=\"number\"\n          name=\"number\"\n          :id=\"String(index)\"\n          v-model=\"arr1[index]\"\n        />\n      </div>\n    </div>\n    <div class=\"table\">\n      <div v-for=\"(_, index) in arrY\" :key=\"index\">\n        <input\n          type=\"number\"\n          name=\"number\"\n          :id=\"String(index)\"\n          v-model=\"arr2[index]\"\n          class=\"cell\"\n        />\n      </div>\n    </div>\n    Elements = {{ size }}\n    <div>Residual Term Lagrange = {{ maxL }}</div>\n    <div>Residual Term Newton = {{ maxN }}</div>\n    <div>[alpha,betta]: [{{ a }},{{ b }}]</div>\n    <div class=\"buttons\">\n      <button @click=\"LagrangeButtonClick\">Lagrange</button>\n      <button @click=\"NewtonButtonClick\">Newton</button>\n      <button @click=\"NewtonForwardButtonClick\">Newton Forward</button>\n      <button @click=\"NewtonBackButtonClick\">Newton Back</button>\n    </div>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport { ref, Ref, ComputedRef } from \"@vue/reactivity\";\nimport { computed } from \"@vue/runtime-core\";\n\nlet size = ref(4);\nlet arr1: Ref<Array<number>> = ref([]);\nlet arr2: Ref<Array<number>> = ref([]);\nlet x = ref(0);\nlet sum = ref(0);\nlet n = ref(10);\nlet a = ref(1);\nlet b = ref(2);\nlet m = ref(10000);\nlet maxL = ref(0);\nlet maxN = ref(0);\n\nlet h = computed((): number => (b.value - a.value) / n.value);\n\nlet sumEl = computed(() => {\n  return arr1.value.reduce(function (a, b) {\n    return Number(a) + Number(b);\n  });\n});\n\nlet sumEl2 = computed(() => {\n  return arr2.value.reduce(function (a, b) {\n    return Number(a) + Number(b);\n  });\n});\n\nlet arr = computed(() => {\n  let arr = [];\n  for (let i = 0; i < size.value; i++) {\n    arr.push(arr1.value[i] ?? 0);\n  }\n  createMatrix(arr);\n  return arr;\n});\nlet arrY = computed(() => {\n  let iarr2 = [];\n  for (let i = 0; i < size.value; i++) {\n    iarr2.push(arr2.value[i] ?? 0);\n  }\n  createMatrix2(iarr2);\n  return iarr2;\n});\n\n// helpers\n\nconst createMatrix = (arr: Array<number>) => {\n  arr1.value = arr;\n};\nconst createMatrix2 = (arr: Array<number>) => {\n  arr2.value = arr;\n};\n\nconst factorialize = (num: number): number => {\n  if (num < 0) return -1;\n  else if (num == 0) return 1;\n  else {\n    return num * factorialize(num - 1);\n  }\n};\n\nlet arrCheshibov: ComputedRef<Array<number>> = computed(() => {\n  let arr: Array<number> = [];\n\n  for (let i = 0; i < n.value + 1; i++) {\n    arr.push(Cheshibov(i));\n  }\n\n  return arr;\n});\n\nlet f = (x: number) => {\n  return x ** 2 - x ** 3;\n};\n\nconst myRandomInts = (quantity: number, min: number, max: number) => {\n  let arr = [];\n  while (arr.length < quantity) {\n    var candidateInt = Math.random() * (max - min) + min;\n    if (arr.indexOf(candidateInt) === -1) arr.push(candidateInt);\n  }\n  return arr;\n};\n\n// buttons\n\nconst LagrangeButtonClick = () => {\n  let arrF1 = [];\n\n  let arrCheshibov: Array<number> = arrCheshibov.value;\n\n  for (let i = 0; i < n.value + 1; i++) {\n    arrF1.push(f(arrCheshibov[i]));\n  }\n\n  arr1.value = [...arrCheshibov];\n  arr2.value = [...arrF1];\n  size.value = n.value + 1;\n  let max = 0;\n\n  for (let i = 0; i < m.value; i++) {\n    let el = a.value + ((b.value - a.value) / m.value) * i;\n    let num1 = f(el);\n    let num2 = Lagrange(el);\n    let el2 = num1 - num2;\n    if (max < Math.abs(el2)) {\n      max = Math.abs(el2);\n    }\n  }\n\n  maxL.value = max;\n};\n\nconst NewtonButtonClick = () => {\n  let arrX = myRandomInts(n.value + 1, a.value, b.value);\n  arrX.sort((a, b) => a - b);\n\n  let arrY = arrX.map((el) => f(el));\n  arr1.value = [...arrX];\n  arr2.value = [...arrY];\n  size.value = n.value + 1;\n  let max = 0;\n\n  for (let i = 0; i < m.value; i++) {\n    let el = a.value + ((b.value - a.value) / m.value) * i;\n    let num1 = f(el);\n    let num2 = Newton(el);\n    let el2 = num1 - num2;\n    if (max < Math.abs(el2)) {\n      max = Math.abs(el2);\n    }\n  }\n\n  maxN.value = max;\n};\n\nconst NewtonForwardButtonClick = () => {\n  let arrX = [];\n  for (let i = 0; i < n.value; i++) {\n    arrX.push(a.value + i * h.value);\n  }\n\n  let arrY = arrX.map((el) => f(el));\n  arr1.value = [...arrX];\n  arr2.value = [...arrY];\n  size.value = n.value;\n  let max = 0;\n\n  for (let i = 0; i < m.value; i++) {\n    let el = a.value + ((b.value - a.value) / m.value) * i;\n    let num1 = f(el);\n    let num2 = NewtonF(el);\n    let el2 = num1 - num2;\n    if (max < Math.abs(el2)) {\n      max = Math.abs(el2);\n    }\n  }\n  maxL.value = max;\n};\n\nconst NewtonBackButtonClick = () => {\n  let arrX = [];\n  for (let i = 0; i < n.value; i++) {\n    arrX.push(a.value + i * h.value);\n  }\n\n  let arrY = arrX.map((el) => f(el));\n  arr1.value = [...arrX];\n  arr2.value = [...arrY];\n  size.value = n.value;\n  let max = 0;\n\n  for (let i = 0; i < m.value; i++) {\n    let el = a.value + ((b.value - a.value) / m.value) * i;\n    let num1 = f(el);\n    let num2 = NewtonB(el);\n    let el2 = num1 - num2;\n    if (max < Math.abs(el2)) {\n      max = Math.abs(el2);\n    }\n  }\n  maxL.value = max;\n};\n\nconst NewtonF = (x: number) => {\n  let arrX = arr1.value;\n  let arrY = arr2.value;\n  let arrRes = [[...arrY]];\n  for (let i = 0; i < n.value - 1; i++) {\n    let arrT = [];\n    for (let j = 0; j < n.value - i - 1; j++) {\n      let el = arrRes[i][j + 1] - arrRes[i][j];\n      arrT.push(el);\n    }\n    arrRes.push(arrT);\n  }\n  let N = 0;\n  for (let i = 0; i < arrRes.length; i++) {\n    let m = arrRes[i][0];\n    for (let j = 0; j < i; j++) {\n      m *= x - arrX[j];\n    }\n    N += m / (factorialize(i) * h.value ** i);\n  }\n  return N;\n};\n\nconst NewtonB = (x: number) => {\n  let arrX = arr1.value;\n  let arrY = arr2.value;\n  let arrRes = [[...arrY]];\n  for (let i = 0; i < n.value - 1; i++) {\n    let arrT = [];\n    for (let j = 0; j < n.value - i - 1; j++) {\n      let el = arrRes[i][j + 1] - arrRes[i][j];\n      arrT.push(el);\n    }\n    arrRes.push(arrT);\n  }\n  let N = 0;\n  for (let i = 0; i < arrRes.length; i++) {\n    let m = arrRes[i][arrRes[i].length - 1];\n    for (let j = 0; j < i; j++) {\n      m *= x - arrX[arrRes.length - j - 1];\n    }\n    N += m / (factorialize(i) * h.value ** i);\n  }\n  return N;\n};\nconst Cheshibov = (i: number) => {\n  let el1 = (b.value + a.value) / 2;\n  let el2 =\n    ((b.value - a.value) / 2) *\n    Math.cos(((2 * i + 1) / (2 * (n.value + 1))) * Math.PI);\n  return el1 + el2;\n};\n\nconst Lagrange = (x: number) => {\n  let sum = 0;\n  let arrX = arr1.value;\n  let arrY = arr2.value;\n  for (let i = 0; i < size.value; i++) {\n    let arrX2 = [...arrX];\n    arrX2.splice(i, 1);\n    let a = 1;\n    let b = 1;\n    for (let j = 0; j < size.value - 1; j++) {\n      a *= x - arrX2[j];\n      b *= arrX[i] - arrX2[j];\n    }\n    sum += arrY[i] * (a / b);\n  }\n  return sum;\n};\n\nconst Newton = (x: number) => {\n  let arrX = arr1.value;\n  let arrY = arr2.value;\n  let arrRes = [[...arrY]];\n  for (let i = 0; i < n.value - 1; i++) {\n    let arrT = [];\n    for (let j = 0; j < n.value - i - 1; j++) {\n      let el = (arrRes[i][j + 1] - arrRes[i][j]) / (arrX[j + 1 + i] - arrX[j]);\n      arrT.push(el);\n    }\n    arrRes.push(arrT);\n  }\n  let N = 0;\n  for (let i = 0; i < arrRes.length; i++) {\n    let m = arrRes[i][0];\n    for (let j = 0; j < i; j++) {\n      m *= x - arrX[j];\n    }\n    N += m;\n  }\n  return N;\n};\n</script>\n<style lang=\"scss\" scoped>\nhtml {\n  display: flex;\n}\n.table {\n  display: flex;\n  flex-direction: row;\n  margin: 10px;\n}\n.buttons {\n  display: flex;\n  flex-direction: row;\n  button {\n    margin: 5px;\n    width: 100px;\n  }\n}\n</style>\n","/Users/muromac/uni/miroslavaLabs/src/views/labTwo.vue",[],"/Users/muromac/uni/miroslavaLabs/src/views/labOne.vue",[],"/Users/muromac/uni/miroslavaLabs/src/views/labFour.vue",[],"/Users/muromac/uni/miroslavaLabs/src/functions/gaus.ts",[],"/Users/muromac/uni/miroslavaLabs/src/functions/jakobi.ts",["64","65","66","67","68","69","70"],"import { sum_array } from \"./zeidel\";\n\nexport function method_yacobi(matrix: any, vector: any, eps: any) {\n  let counter = 0;\n  const res = [];\n  let xVector = new Array(matrix.length).fill(0);\n  const el: { [key: string]: any } = {};\n  let converge = false;\n\n  while (!converge) {\n    const test = [];\n\n    for (let i = 0; i < matrix.length; i++) {\n      const xNew = Object.assign({}, xVector);\n      xNew[i] = 1;\n      el[`s${i}`] = matrix[i].map((element: any) => element * -1);\n      el[`s${i}`][i] = vector[i];\n      el[`s${i}`] = el[`s${i}`].map((element: any) => element / matrix[i][i]);\n      el[`s${i}_sum`] = sum_array(\n        el[`s${i}`].map((element: any, index: number) => element * xNew[index])\n      );\n      test[i] = el[`s${i}_sum`].toFixed(4);\n    }\n\n    converge = Math.abs(sum_array(xVector) - sum_array(test)) <= eps;\n    xVector = test;\n    res.push(xVector);\n    counter = counter + 1;\n  }\n\n  const lol = [`counter=${counter}`];\n  res.push([lol]);\n  return res;\n}\n","/Users/muromac/uni/miroslavaLabs/src/functions/zeidel.ts",["71","72","73","74"],"export const method_zeidel = (matrix: any, vector: any, eps: any) => {\n  const res = [];\n  const xVector = new Array(matrix.length).fill(0);\n  const el: { [key: string]: any } = {};\n  let con = false;\n  let counter = 0;\n\n  while (!con) {\n    let xOld;\n    if (counter == 0) {\n      xOld = new Array(matrix.length).fill(0);\n    } else {\n      xOld = Object.assign([], xVector);\n    }\n\n    for (let i = 0; i < matrix.length; i++) {\n      const xNew = Object.assign({}, xVector);\n      xNew[i] = 100;\n      el[`s${i}`] = matrix[i].map((element: number) => element * -1);\n      el[`s${i}`][i] = vector[i];\n      el[`s${i}`] = el[`s${i}`].map(\n        (element: number) => element / matrix[i][i]\n      );\n      console.log(el);\n      el[`s${i}_sum`] = sum_array(\n        el[`s${i}`].map(\n          (element: number, index: number) => element * xNew[index]\n        )\n      );\n      el[`s${i}_sum`] = Math.abs(el[`s${i}_sum`]);\n      console.log(el, xVector);\n      xVector[i] = el[`s${i}_sum`].toFixed(4);\n    }\n    res.push(Object.assign([], xVector));\n    con = Math.abs(sum_array(xVector) - sum_array(xOld)) <= eps;\n    counter++;\n  }\n  const el1 = [`counter=${counter}`];\n  res.push([el1]);\n  return res;\n};\n\nexport const sum_array = (arr: Array<number>) => {\n  let summ = 0;\n  for (let i = 0; i < arr.length; i++) {\n    summ += Number(arr[i]);\n  }\n  return summ;\n};\n","/Users/muromac/uni/miroslavaLabs/src/functions/determinant.ts",[],"/Users/muromac/uni/miroslavaLabs/src/functions/inverse.ts",[],{"ruleId":"75","severity":1,"message":"76","line":45,"column":5,"nodeType":"77","messageId":"78","endLine":45,"endColumn":6},{"ruleId":"75","severity":1,"message":"79","line":46,"column":5,"nodeType":"77","messageId":"78","endLine":46,"endColumn":8},{"ruleId":"75","severity":1,"message":"80","line":56,"column":5,"nodeType":"77","messageId":"78","endLine":56,"endColumn":10},{"ruleId":"75","severity":1,"message":"81","line":62,"column":5,"nodeType":"77","messageId":"78","endLine":62,"endColumn":11},{"ruleId":"75","severity":1,"message":"82","line":102,"column":5,"nodeType":"77","messageId":"78","endLine":102,"endColumn":45},{"ruleId":"83","severity":1,"message":"84","line":3,"column":39,"nodeType":"85","messageId":"86","endLine":3,"endColumn":42,"suggestions":"87"},{"ruleId":"83","severity":1,"message":"84","line":3,"column":52,"nodeType":"85","messageId":"86","endLine":3,"endColumn":55,"suggestions":"88"},{"ruleId":"83","severity":1,"message":"84","line":3,"column":62,"nodeType":"85","messageId":"86","endLine":3,"endColumn":65,"suggestions":"89"},{"ruleId":"83","severity":1,"message":"84","line":7,"column":30,"nodeType":"85","messageId":"86","endLine":7,"endColumn":33,"suggestions":"90"},{"ruleId":"83","severity":1,"message":"84","line":16,"column":45,"nodeType":"85","messageId":"86","endLine":16,"endColumn":48,"suggestions":"91"},{"ruleId":"83","severity":1,"message":"84","line":18,"column":47,"nodeType":"85","messageId":"86","endLine":18,"endColumn":50,"suggestions":"92"},{"ruleId":"83","severity":1,"message":"84","line":20,"column":35,"nodeType":"85","messageId":"86","endLine":20,"endColumn":38,"suggestions":"93"},{"ruleId":"83","severity":1,"message":"84","line":1,"column":39,"nodeType":"85","messageId":"86","endLine":1,"endColumn":42,"suggestions":"94"},{"ruleId":"83","severity":1,"message":"84","line":1,"column":52,"nodeType":"85","messageId":"86","endLine":1,"endColumn":55,"suggestions":"95"},{"ruleId":"83","severity":1,"message":"84","line":1,"column":62,"nodeType":"85","messageId":"86","endLine":1,"endColumn":65,"suggestions":"96"},{"ruleId":"83","severity":1,"message":"84","line":4,"column":30,"nodeType":"85","messageId":"86","endLine":4,"endColumn":33,"suggestions":"97"},"@typescript-eslint/no-unused-vars","'x' is assigned a value but never used.","Identifier","unusedVar","'sum' is assigned a value but never used.","'sumEl' is assigned a value but never used.","'sumEl2' is assigned a value but never used.","'arrCheshibov' is assigned a value but never used.","@typescript-eslint/no-explicit-any","Unexpected any. Specify a different type.","TSAnyKeyword","unexpectedAny",["98","99"],["100","101"],["102","103"],["104","105"],["106","107"],["108","109"],["110","111"],["112","113"],["114","115"],["116","117"],["118","119"],{"messageId":"120","fix":"121","desc":"122"},{"messageId":"123","fix":"124","desc":"125"},{"messageId":"120","fix":"126","desc":"122"},{"messageId":"123","fix":"127","desc":"125"},{"messageId":"120","fix":"128","desc":"122"},{"messageId":"123","fix":"129","desc":"125"},{"messageId":"120","fix":"130","desc":"122"},{"messageId":"123","fix":"131","desc":"125"},{"messageId":"120","fix":"132","desc":"122"},{"messageId":"123","fix":"133","desc":"125"},{"messageId":"120","fix":"134","desc":"122"},{"messageId":"123","fix":"135","desc":"125"},{"messageId":"120","fix":"136","desc":"122"},{"messageId":"123","fix":"137","desc":"125"},{"messageId":"120","fix":"138","desc":"122"},{"messageId":"123","fix":"139","desc":"125"},{"messageId":"120","fix":"140","desc":"122"},{"messageId":"123","fix":"141","desc":"125"},{"messageId":"120","fix":"142","desc":"122"},{"messageId":"123","fix":"143","desc":"125"},{"messageId":"120","fix":"144","desc":"122"},{"messageId":"123","fix":"145","desc":"125"},"suggestUnknown",{"range":"146","text":"147"},"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct.","suggestNever",{"range":"146","text":"148"},"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of.",{"range":"149","text":"147"},{"range":"149","text":"148"},{"range":"150","text":"147"},{"range":"150","text":"148"},{"range":"151","text":"147"},{"range":"151","text":"148"},{"range":"152","text":"147"},{"range":"152","text":"148"},{"range":"153","text":"147"},{"range":"153","text":"148"},{"range":"154","text":"147"},{"range":"154","text":"148"},{"range":"155","text":"147"},{"range":"155","text":"148"},{"range":"156","text":"147"},{"range":"156","text":"148"},{"range":"157","text":"147"},{"range":"157","text":"148"},{"range":"158","text":"147"},{"range":"158","text":"148"},[77,80],"unknown","never",[90,93],[100,103],[223,226],[460,463],[563,566],[665,668],[38,41],[51,54],[61,64],[170,173]]